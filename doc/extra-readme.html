<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>README – Moebius v1.0.0</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.10.0">
    <link rel="stylesheet" href="dist/app.css" />
    <script src="dist/sidebar_items.js"></script>
  </head>
  <body data-type="extras">

<div class="main">
<button class="sidebar-toggle">
  <i class="icon-menu"></i>
</button>
<section class="sidebar">
  <button class="sidebar-toggle">
    <i class="icon-menu"></i>
  </button>

  
  <a href="Moebius.Query.html" class="sidebar-projectLink">
    <div class="sidebar-projectDetails">
      <h1 class="sidebar-projectName">
        Moebius
      </h1>
      <h2 class="sidebar-projectVersion">
        v1.0.0
      </h2>
    </div>
    
  </a>

  <div class="sidebar-search">
    <i class="icon-search"></i>
    <input type="text" class="sidebar-searchInput" placeholder="search" autocomplete="off" />
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>

    
      <li><a id="modules-list" href="#full-list">Modules</a></li>
    

    

    
  </ul>

  <ul id="full-list" class="sidebar-fullList"></ul>
  <div class="sidebar-noResults"></div>
</section>

<section class="content">
  <div id="content" class="content-inner">


<p><img src="https://travis-ci.org/robconery/moebius.svg?branch=master" alt="travis"/> <a href="https://hex.pm/packages/moebius"><img src="https://img.shields.io/hexpm/v/moebius.svg" alt="Hex.pm Version"/></a></p>
<h1>Moebius: A functional query tool for Elixir and PostgreSQL.</h1>
<p>I love working with Elixir but so far there hasn’t been all that much choice when working with a database. Ecto works very well, but to me ORMs are just a bit out of place in the functional landscape of Elixir. I wanted to explore some options, so I made this package.</p>
<p><em>Please note</em>: This started as a bit of a “spike”, if you will. <a href="https://soundcloud.com/elixirfountain/elixir-fountain-2015-10-16-rob-conery">I mentioned on the ElixirFountain podcast</a> that there were approaches and concepts in Ecto that I found a bit confusing. Namely:</p>
<ul>
<li>An object-oriented concept in a functional language
</li>
<li>A generic “Repository” interface (CRUD ops) that <a href="http://martinfowler.com/eaaCatalog/repository.html">isn’t really a Repository</a> which is OK, it’s just a bit confusing.
</li>
<li>A very close resemblance to ActiveRecord, which I am not a fan of
</li>
</ul>
<p>Those are negative things. There are quite a few positives in there - it’s some of the best code I’ve ever seen and <a href="https://github.com/elixir-lang/ecto">reading the source</a> is one of the main ways I learned Elixir. These are the early days - this repo is here to demonstrate some ideas and, possibly, to build on.</p>
<p>No, <strong>Moebius won’t run on MySQL</strong>. It’s a dedicated PostgreSQL solution.</p>
<h2 id="Inspiration"> Inspiration</h2><p>If you’ve <a href="http://sequel.jeremyevans.net/rdoc/">ever used Sequel</a> for Ruby, this will look familiar to you. At its core, Moebius embraces the idea of pushing/transforming data through a functional pipeline. You select/shape/reduce as you need.</p>
<p>This is still very much a work in progress.</p>
<h2 id="Installation"> Installation</h2><p>Installing Moebius is pretty straightforward:</p>
<ol>
<li><p>Add moebius to your list of dependencies in <code class="inline">mix.exs</code>:</p>
<pre><code class="elixir">def deps do
  [{:moebius, &quot;~&gt; 0.0.1&quot;}]
end</code></pre>
</li>
<li><p>Ensure moebius is started before your application:</p>
<pre><code class="elixir">def application do
  [applications: [:moebius]]
end</code></pre>
</li>
</ol>
<p>Next, in your config, specify how to connect. We just pass along the connection bits to Postgrex (the PG driver) so you can add whatever you want based on their options:</p>
<pre><code class="elixir">config :moebius, connection: [database: &quot;MY_DB&quot;, extensions: [{Postgrex.Extensions.JSON, library: Poison}]], scripts: &quot;test/db&quot;</code></pre>
<h2 id="Simple-Examples"> Simple Examples</h2><p>Here are some very, very basic examples. I’m sure the API will be changing in a big way - so if you want to see what’s happening (until I bake this a bit) please have a look at the test.</p>
<p>Everything starts with the db:</p>
<pre><code class="ex">cmd = db(:users)</code></pre>
<p>That produces the <code class="inline">QueryCommand</code> that we will then shape as we need:</p>
<pre><code class="ex">cmd = db(:users)
    |&gt; filter(id: 1)</code></pre>
<p>We still have a command here, one that we can pass along and do all kinds of things with:</p>
<pre><code class="ex">cmd = db(:users)
    |&gt; filter(id: 1, name: &quot;Steve&quot;)
    |&gt; sort(:name, :desc)
    |&gt; limit(10)
    |&gt; offset(2)
    |&gt; select</code></pre>
<p>If I did the API right, this should be pretty obvious. And no, order is not important. The final bit there builds a <code class="inline">:select</code> command from what has come before. We can execute it thus:</p>
<pre><code class="ex">{:ok, res} = db(:users)
    |&gt; filter(id: 1, name: &quot;Steve&quot;)
    |&gt; sort(:name, :desc)
    |&gt; limit(10)
    |&gt; offset(2)
    |&gt; select
    |&gt; run</code></pre>
<p>An <code class="inline">IN</code> query happens when you pass an array:</p>
<pre><code class="ex">{:ok, res} = db(:users)
    |&gt; filter(:name, [&quot;mark&quot;, &quot;biff&quot;, &quot;skip&quot;])
    |&gt; select
    |&gt; run

#or, if you want to be more precise

{:ok, res} = db(:users)
    |&gt; filter(:name, in: [&quot;mark&quot;, &quot;biff&quot;, &quot;skip&quot;])
    |&gt; select
    |&gt; run</code></pre>
<p>A NOT IN query happens when you specify the <code class="inline">not_in</code> key:</p>
<pre><code class="ex">{:ok, res} = db(:users)
    |&gt; filter(:name, not_in: [&quot;mark&quot;, &quot;biff&quot;, &quot;skip&quot;])
    |&gt; select
    |&gt; run</code></pre>
<p>If you don’t want to deal with my abstractions, just use SQL:</p>
<pre><code class="ex">{:ok, res} = run &quot;select * from users where id=1 limit 1 offset 1;&quot;</code></pre>
<h2 id="Full-Text-indexing"> Full Text indexing</h2><p>Because I love it:</p>
<pre><code class="ex">{:ok, res} = db(:users)
      |&gt; search(&quot;Mike&quot;, [:first, :last, :email])
      |&gt; run</code></pre>
<p>The <code class="inline">search</code> function builds a <code class="inline">tsvector</code> search on the fly for you and executes it over the columns you send in. The results are ordered in descending order using <code class="inline">ts_rank</code></p>
<h2 id="SQL-Files"> SQL Files</h2><p>I built this for <a href="https://github.com/robconery/massive-js">MassiveJS</a> and I liked the idea, which is this: <em>some people love SQL</em>. I’m one of those people. I’d much rather work with a SQL file than muscle through some weird abstraction.</p>
<p>With this library you can do that. Just create a scripts directory and specify it in the config (see above), then execute:</p>
<pre><code class="ex">{:ok, res} = sql_file(:my_groovy_query, &quot;a param&quot;)
  |&gt; single</code></pre>
<h2 id="Adding-Updating-Deleting"> Adding, Updating, Deleting</h2><p>Inserting is pretty straightforward:</p>
<pre><code class="ex">{:ok, res} = db(:users)
    |&gt; insert(email: &quot;test@test.com&quot;, first: &quot;Test&quot;, last: &quot;User&quot;)
    |&gt; execute</code></pre>
<p>Updating can work over multiple rows, or just one, depending on the filter you use:</p>
<pre><code class="ex">{:ok, res} = db(:users)
    |&gt; filter(id: 1)
    |&gt; update(email: &quot;maggot@test.com&quot;)
    |&gt; execute</code></pre>
<p>The filter can be a single record, or affect multiple records:</p>
<pre><code class="ex">{:ok, res} = db(:users)
    |&gt; filter(&quot;id &gt; 100&quot;)
    |&gt; update(email: &quot;test@test.com&quot;)
    |&gt; execute

{:ok, res} = db(:users)
    |&gt; filter(&quot;email LIKE %$2&quot;, &quot;test&quot;)
    |&gt; update(email: &quot;ox@test.com&quot;)
    |&gt; execute</code></pre>
<p>Deleting works exactly the same way as <code class="inline">update</code>:</p>
<pre><code class="ex">{:ok, res} = db(:users)
    |&gt; filter(&quot;email LIKE %$2&quot;, &quot;test&quot;)
    |&gt; delete
    |&gt; execute</code></pre>
<h2 id="Table-Joins"> Table Joins</h2><p>Table joins can be applied for a single join or piped to create multiple joins. The table names can be either atoms or binary strings. There are a number of options to customize your joins:</p>
<pre><code class="ex">:join        # set the type of join. LEFT, RIGHT, FULL, etc. defaults to INNER
  :on          # specify the table to join on
  :foreign_key # specify the tables foreign key column
  :primary_key # specify the joining tables primary key column
  :using       # used to specify a USING queries list of columns to join on</code></pre>
<p>The simplest example is a basic join:</p>
<pre><code class="ex">{:ok, res} = db(:customers)
    |&gt; join(:orders)
    |&gt; select
    |&gt; execute</code></pre>
<p>For multiple table joins you can specify the table that you want to join on:</p>
<pre><code class="ex">{:ok, res} = db(:customers)
    |&gt; join(:orders, on: :customers)
    |&gt; join(:items, on: :orders)
    |&gt; select
    |&gt; execute</code></pre>
<h2 id="Transactions"> Transactions</h2><p>I’m still working on an approach for this, but my initial inclination is usually to write SQL that does exactly what I want. I <em>will</em> have something in place in a week or so, but if you are OK using SQL, then build yourself a CTE (have a look in the test/db directory at <code class="inline">cte.sql</code>) which is a transactional operation. You’ll write less code probably :).</p>
<h2 id="Aggregates-etc"> Aggregates etc</h2><p>I still need to build these - just a matter of time. Probably happen this week.</p>
<h2 id="Help-Please-"> Help? Please?</h2><p>Even if you tell me this sucks, that’s still helpful :). I’d love any that you want to give.</p>
<h2 id="Documentation"> Documentation</h2><p>API documentation is available at <a href="http://hexdocs.pm/moebius">http://hexdocs.pm/moebius</a></p>
<h2 id="Building-docs-from-source"> Building docs from source</h2><pre><code class="bash">$ MIX_ENV=dev mix docs</code></pre>

    <footer class="footer">
      <p>
        <span class="line">
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" rel="help" target="_blank">ExDoc</a> (v0.10.0),
        </span>
        <span class="line">
          designed by
          <a href="https://twitter.com/dignifiedquire" target="_blank" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
      </p>
    </footer>
  </div>
</section>
</div>
    <script src="dist/app.js"></script>
  </body>
</html>

